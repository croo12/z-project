# 적응형 기사 추천 시스템 PRD (요구사항 정의서)

## 1. 개요
**목표**: 개발자의 명시적 관심사로 시작하여, 상호작용 패턴에 따라 진화하는 고도로 개인화된 기술 뉴스 피드를 제공합니다.

**문제 정의**: 개발자들은 너무 포괄적인 기술 뉴스에 압도당하고 있습니다. 그들은 수동으로 필터링할 필요 없이 자신의 기술 스택(예: Rust, React)과 관련된 "신호(Signal)가 높은" 콘텐츠를 원합니다.

## 2. 사용자 스토리

### 2.1 초기 설정 (온보딩)
- **사용자로서**, 앱을 처음 시작할 때 주요 관심 분야(예: "Rust", "Front-end", "AI", "Mobile")를 선택하고 싶습니다.
- **사용자로서**, 시스템이 나에 대해 아무것도 모르는 "콜드 스타트(Cold Start)" 기간 없이, 선택한 관심사와 즉시 관련된 기사를 보고 싶습니다.

### 2.2 소비 및 추천
- **사용자로서**, 선택한 카테고리를 우선시하는 일일 기사 피드를 받고 싶습니다.
- **사용자로서**, 저품질이거나 관련 없는 콘텐츠(예: 기술로 위장한 일반 금융 뉴스)가 필터링되기를 원합니다.
- **사용자로서**, 인기 있는 기사(내 카테고리의 트렌드)와 "숨겨진 보석"(AI가 큐레이션한 맞춤 기사)이 적절히 섞여서 보이기를 원합니다.

### 2.3 피드백 및 적응 ("머신러닝" 루프)
- **사용자로서**, 기사에 대해 빠른 피드백(예: "유용함", "관련 없음")을 제공하고 싶습니다.
- **사용자로서**, 시스템이 이 피드백으로부터 학습하기를 기대합니다. 만약 내가 "기술"을 선택했음에도 "블록체인" 기사를 지속적으로 싫어한다면, 시스템은 이를 더 이상 보여주지 않아야 합니다.
- **사용자로서**, 시스템이 내 독서 습관을 AI로 분석하여 시간이 지남에 따라 구체적인 선호도(예: "상세한 코드 튜토리얼을 선호함", "추상적인 오피니언 글은 싫어함")를 추론하기를 기대합니다.

## 3. 기능 요구사항

### 3.1 선호도 관리
- **카테고리 선택 UI**: 설정 또는 온보딩 화면에서 다중 선택 가능한 카테고리 제공 (Rust, Tauri, React, TypeScript, Android, Kotlin, Web, AI, General).
- **영속성**: 사용자 설정을 로컬에 저장합니다.

### 3.2 추천 엔진 로직
엔진은 하이브리드 모드로 작동해야 합니다:
1.  **1단계: 명시적 필터링**: 사용자가 *선택한 카테고리*에 해당하는 기사에 높은 가중치를 부여합니다.
2.  **2단계: 암시적 페르소나 (AI)**: 피드백에서 도출된 `UserPersona`를 사용하여 재정렬하거나 상위 기사를 선택합니다.
    *   *입력*: 사용자가 선택한 카테고리 + 사용자 페르소나 (AI가 생성한 설명).
    *   *프로세스*: 후보군 필터링 -> 관련성 점수 산정 -> AI 선택을 통한 최종 피드 구성.

### 3.3 피드백 루프
- **액션**: 기사 카드에 "좋아요" / "싫어요" (유사한 형태) 버튼 추가.
- **처리 과정 (Rolling Update Strategy)**:
    1.  사용자가 피드백을 남기면, 해당 피드백을 로컬 DB에 임시 저장.
    2.  일정 개수(예: 3~5개)가 모이거나 앱 종료 시 "페르소나 업데이트" 트리거.
    3.  **LLM Input**: [기존 페르소나 요약] + [최근 새로운 피드백 3~5개]
    4.  **LLM Output**: [새로운 페르소나 요약]
    *   *핵심*: 전체 피드백 히스토리를 매번 보내는 것이 아니라, 기존 페르소나에 새로운 정보를 **병합(Merge)** 하는 방식이므로 **토큰 사용량이 일정하게 유지(O(1))** 됩니다.

### 3.4 카테고리 분류 전략 (Categorization Strategy - Multi-Tags)
- **다중 태그 지원 (Multi-Category)**:
    - 아티클은 더 이상 하나의 카테고리만 갖지 않습니다. (예: `["Rust", "Android"]`)
    - **DB 스키마 변경**: `category` 컬럼 -> `tags` (JSON String or Comma-separated)
- **분류 로직**:
    1.  **출처 기반 (Source)**: 기본 태그 부여 (예: Rust Blog -> `["Rust"]`)
    2.  **키워드 기반 확장 (Keyword Extension)**: 제목/요약을 분석하여 *상관없는 소스*에서도 태그를 추가합니다. (예: 안드로이드 블로그에서 "Rust로 NDK 개발하기" -> `["Android", "Rust"]`)

### 3.5 중복 제거 전략 (Deduplication)
- **고유 식별자 (Unique Identifier)**: 정규화된 URL (Normalized URL)을 사용합니다.
    - `utm_source` 등 트래킹 파라미터 제거.
    - `http` vs `https`, `www.` 유무 통일.
- **병합 로직 (Upsert Strategy)**:
    - 이미 존재하는 URL의 기사가 수집되면, **새로운 소스의 태그를 기존 기사에 병합(Merge)** 합니다.
    - 예: A블로그(Rust)에서 수집된 글이 B블로그(General)에서도 발견되면 -> 태그는 `["Rust", "General"]`이 됨.

### 3.6 데이터 아키텍처 (Article DB Strategy)
- **중앙 저장소 (Central Repository)**: 모든 수집된 아티클은 로컬 SQLite `articles` 테이블(Article DB)에 영구 저장됩니다.
- **데이터 흐름 (Ingestion Flow)**:
    1.  **Fetcher**: 외부 RSS/API에서 데이터 수집.
    2.  **Ingestor**:
        - **New**: DB에 없는 URL이면 -> `INSERT`.
        - **Exist**: DB에 있는 URL이면 -> 태그 병합 후 `UPDATE` (Last Seen 갱신).
    3.  **App**: UI에는 항상 **Article DB**에서 쿼리한 결과를 보여줍니다. (Source와 UI의 분리)
- **장기적 가치**: 이렇게 누적된 데이터셋은 추후 온디바이스 학습이나 고급 추천 모델의 학습 데이터로 활용됩니다.

## 4. 기술 구현 가이드라인

### 백엔드 (Rust/Tauri)
- **DB Migration**: 기존 `articles` 테이블의 `category` 컬럼을 `tags` (TEXT)로 마이그레이션.
- **Repository Pattern**: `RecommendationState` 내에 `ArticleRepository` 로직 분리 권장.
- **Fetch Logic**: `INSERT ... ON CONFLICT(url) DO UPDATE SET tags = ...` 로직 적용.

### 프론트엔드 (React/TypeScript)
- **신규**: 카테고리 토글을 위한 `OnboardingModal` 또는 `SettingsPanel` 컴포넌트 생성.
- **업데이트**: `ArticleList`에 피드백 컨트롤(좋아요/싫어요) 추가.

## 5. 성공 지표
- **관련성**: 추천된 기사에 대한 사용자의 "좋아요" 비율이 시간이 지남에 따라 증가.
- **참여도**: 사용자가 전체 기사를 읽기 위해 클릭하는 빈도 증가.
